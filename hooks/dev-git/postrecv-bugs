#!/bin/bash
# Copyright 2017 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2 or later

# Author: Michał Górny <mgorny@gentoo.org>

export LANG=en_US.UTF-8
export LC_MESSAGES=C
export TZ=UTC

shopt -o -s noglob

ALLOWED_BRANCHES=$(git config --get gentoo.bugs.allowed-branches)

declare -A COMMENT_BUGS=()
declare -A CLOSE_BUGS=()
declare -A UNCC_BUGS=()

# things we are allowed to recognize and unCC
ALL_ARCHES=(
    alpha amd64 arm hppa ia64 ppc64 ppc x86 arm64
    amd64-fbsd x86-fbsd m68k mips s390 sh sparc
)

while read -r oldrev newrev refname; do
    # operate only on branches in gentoo.bugs.allowed-branches
    # (or 'master' if unset)
    allowed=0
    for allowed_branch in ${ALLOWED_BRANCHES:-master}; do
        if [[ ${refname#refs/heads/} == ${allowed_branch} ]]; then
            allowed=1
            break
        fi
    done
    [[ ${allowed} == 0 ]] && continue

    while read -r commithash; do
        uncc_this=()
        while read -r l; do
            case ${l} in
                # kinda-like github/gitlab/bitbucket but:
                # 1. we accept only -s forms for simplicity,
                # 2. we accept only footer-style to avoid false positives,
                # 3. we have to scan the whole commit message because
                # developers still fail to have just one footer.
                Closes:*|Resolves:*|Fixes:*)
                    close=1;;
                # alternate form to ref without closing
                Bug:*)
                    close=0;;
                # try to detect arch team work
                *[sS]table*|*[sS]tabilize*|*[kK]eyword*)
                    # recognize common foo/bar/baz form
                    split_msg=( ${l//// } )
                    for arch in "${ALL_ARCHES[@]}"; do
                        for word in "${split_msg[@]}"; do
                            if [[ ${word} == ${arch} || ${word} == ALLARCHES ]]; then
                                uncc_this+=( "${arch}@gentoo.org" )
                                break
                            fi
                        done
                    done
                    continue;;
                *)
                    continue;;
            esac

            # strip whitespace, split words
            bugref=( ${l#*:} )
            for bug in "${bugref[@]}"; do
                case ${bug} in
                    # long bugzilla URL
                    http://bugs.gentoo.org/show_bug.cgi\?*|https://bugs.gentoo.org/show_bug.cgi\?*)
                        bugno=${bug#*[?&]id=}
                        bugno=${bugno%%[&#]*}
                        ;;
                    # short bugzilla URL
                    http://bugs.gentoo.org/[0-9]*|https://bugs.gentoo.org/[0-9]*)
                        bugno=${bug##*/}
                        bugno=${bugno%%[?#]*}
                        ;;
                    # silently ignore github, mirror hook will handle it
                    http://github.com/*|https://github.com/*)
                        continue;;
                    *)
                        echo "WARNING: invalid/unsupported bug ref: ${bug}"
                        continue;;
                esac

                if [[ -n ${bugno//[0-9]} ]]; then
                    echo "WARNING: invalid Gentoo Bugzilla URL: ${bug}"
                    continue
                fi

                newmsg="

https://gitweb.gentoo.org/${GL_REPO}.git/commit/?id=${commithash}

$(git show --pretty=fuller --date=iso-local --stat "${commithash}")"
# TODO: --show-signature with some nice short output

                if [[ ${close} == 1 ]]; then
                    CLOSE_BUGS[${bugno}]+=${newmsg}
                else
                    COMMENT_BUGS[${bugno}]+=${newmsg}
                fi

                if [[ ${uncc_this[@]} ]]; then
                    UNCC_BUGS[${bugno}]+=" ${uncc_this[*]}"
                fi
            done
        done < <(git show -q --pretty=format:'%B' "${commithash}")
    done < <(git rev-list "${oldrev}..${newrev}")
done

for bug in "${!CLOSE_BUGS[@]}"; do
    msg="The bug has been closed via the following commit(s):${CLOSE_BUGS[${bug}]}"

    if [[ -n ${COMMENT_BUGS[${bug}]} ]]; then
        msg+="

Additionally, it has been referenced in the following commit(s):${COMMENT_BUGS[${bug}]}}"
    fi

    cmd=( bugz modify -s RESOLVED -r FIXED )
    if [[ -n ${UNCC_BUGS[${bug}]} ]]; then
        cmd+=( --remove-cc "${UNCC_BUGS[${bug}]}" )
    fi
    cmd+=( -c "${msg}" "${bug}" )
    "${cmd[@]}"
done

for bug in "${!COMMENT_BUGS[@]}"; do
    [[ -n ${CLOSE_BUGS[${bug}]} ]] && continue

    msg="The bug has been referenced in the following commit(s):${COMMENT_BUGS[${bug}]}}"

    cmd=( bugz modify )
    if [[ -n ${UNCC_BUGS[${bug}]} ]]; then
        cmd+=( --remove-cc "${UNCC_BUGS[${bug}]}" )
    fi
    cmd+=( -c "${msg}" "${bug}" )
    "${cmd[@]}"
done

for bug in "${!UNCC_BUGS[@]}"; do
    is_kws=
    are_arches_cced=
    is_closed=
    while read -r key colon value; do
        if [[ ${key} == Component && ${value} == Keywording ]]; then
            is_kws=1
            break
        elif [[ ${key} == Component && ${value} == Stabilization ]]; then
            is_kws=1
            break
        elif [[ ${key} == Status && ${value} == RESOLVED ]]; then
            is_closed=1
            break
        elif [[ ${key} == CC ]]; then
            # check whether CC contains any arches
            for arch in "${ALL_ARCHES[@]}"; do
                if [[ ${value} == *${arch}@gentoo.org* ]]; then
                    are_arches_cced=1
                    break
                fi
            done
        fi
    done < <( bugz get -a -n "${bug}" )

    if [[ ${is_kws} && ! ${are_arches_cced} && ! ${is_closed} ]]; then
        bugz modify -s RESOLVED -r FIXED -c "All arches done, closing." "${bug}"
    fi
done

exit 0
